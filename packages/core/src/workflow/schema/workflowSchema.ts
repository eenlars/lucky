import { z } from "zod"

import { getDefaultModels } from "@core/core-config/compat"
import { agentDescriptionsWithTools } from "@core/node/schemas/agentWithTools"
import { mapModelNameToEasyName } from "@core/prompts/explainAgents"
import { MemorySchemaOptional } from "@core/utils/memory/memorySchema"
import type { AnyModelName, ModelName } from "@core/utils/spending/models.types"
import { ACTIVE_MODEL_NAMES } from "@core/utils/spending/pricing"
import type { WorkflowConfig, WorkflowNodeConfig } from "@core/workflow/schema/workflow.types"
import { withDescriptions } from "@lucky/shared"
import { ACTIVE_CODE_TOOL_NAMES_WITH_DEFAULT, ACTIVE_MCP_TOOL_NAMES } from "@lucky/tools/client"

export const WorkflowNodeConfigSchema = z.object({
  nodeId: z.string(),
  description: z.string(),
  systemPrompt: z.string(),
  // Accept any model string - validation happens at runtime via validateAndResolveModel()
  modelName: z.string().refine(name => typeof name === "string" && name.length > 0, {
    message: "Model name must be a non-empty string",
  }),
  mcpTools: z.array(z.enum(ACTIVE_MCP_TOOL_NAMES)),
  codeTools: z.array(z.enum(ACTIVE_CODE_TOOL_NAMES_WITH_DEFAULT)),
  handOffs: z.array(z.string()),
  handOffType: z.enum(["conditional", "sequential", "parallel"]).optional(),
  // enable async joins by allowing nodes to specify required predecessors
  waitFor: z.array(z.string()).optional(),
  memory: MemorySchemaOptional,
})

export const WorkflowConfigSchema = z.object({
  nodes: z.array(WorkflowNodeConfigSchema),
  entryNodeId: z.string(),
  contextFile: z.string().nullish(),
  memory: MemorySchemaOptional,
})

// Display-only schema that allows any model name for legacy workflows
export const WorkflowNodeConfigSchemaDisplay = z.object({
  nodeId: z.string(),
  description: z.string(),
  systemPrompt: z.string(),
  modelName: z.string(), // Allow any string for display
  mcpTools: z.array(z.string()), // Allow any string for legacy tools
  codeTools: z.array(z.string()), // Allow any string for legacy tools
  handOffs: z.array(z.string()),
  handOffType: z.enum(["conditional", "sequential", "parallel"]).optional(),
  waitFor: z.array(z.string()).optional(),
  memory: MemorySchemaOptional,
})

export const WorkflowConfigSchemaDisplay = z.object({
  nodes: z.array(WorkflowNodeConfigSchemaDisplay),
  entryNodeId: z.string(),
  contextFile: z.string().nullish(),
  memory: MemorySchemaOptional,
})

const modelNames = ["low", "medium", "high"] as const

export const WorkflowNodeConfigSchemaEasy = z.object({
  nodeId: z.string(),
  description: z.string(),
  systemPrompt: z.string(),
  // Accept either 'low' | 'medium' | 'high' or any provider model string; we'll normalize later
  modelName: z.string(),
  mcpTools: z.array(z.enum(ACTIVE_MCP_TOOL_NAMES)),
  codeTools: z.array(z.enum(ACTIVE_CODE_TOOL_NAMES_WITH_DEFAULT)),
  handOffs: z.array(z.string()),
  handOffType: z.enum(["conditional", "sequential", "parallel"]).optional(),
  // expose waitFor in the easy schema so the generator can produce async joins
  waitFor: z.array(z.string()).optional(),
})

// For the easy schema, guide the model to use only complexity levels (not provider model names)
const agentDescriptionsWithToolsEasy = {
  ...agentDescriptionsWithTools,
  modelName:
    "Model complexity level. Must be exactly one of: 'low' | 'medium' | 'high'. Choose based on task complexity. Do NOT output provider model IDs here; mapping to actual models happens later.",
} as const

export const WorkflowConfigSchemaEasy = z.object({
  nodes: z.array(withDescriptions(WorkflowNodeConfigSchemaEasy.shape, agentDescriptionsWithToolsEasy)),
  entryNodeId: z.string(),
})

// adds memory and other fields that were just generated by the easy workflow generator
export const handleWorkflowCompletion = (
  oldWorkflow: WorkflowConfig | null,
  newWorkflow: z.infer<typeof WorkflowConfigSchemaEasy>,
): WorkflowConfig => {
  const handledNodes: WorkflowNodeConfig[] = (newWorkflow.nodes ?? []).map(partialNode => {
    const oldNode = oldWorkflow?.nodes?.find(n => n.nodeId === partialNode.nodeId)
    // Normalize model: if an active provider model is specified, keep it.
    // If the easy levels 'low' | 'medium' | 'high' are used, map to configured defaults.
    // Otherwise, map the provider string to an easy level and then to defaults.
    let modelName: ModelName
    if ((ACTIVE_MODEL_NAMES as readonly string[]).includes(partialNode.modelName as unknown as string)) {
      modelName = partialNode.modelName as unknown as ModelName
    } else {
      const easyLevel: (typeof modelNames)[number] =
        partialNode.modelName === "low" || partialNode.modelName === "medium" || partialNode.modelName === "high"
          ? (partialNode.modelName as (typeof modelNames)[number])
          : mapModelNameToEasyName(partialNode.modelName as unknown as AnyModelName)

      modelName =
        easyLevel === "medium"
          ? getDefaultModels().medium
          : easyLevel === "high"
            ? getDefaultModels().high
            : getDefaultModels().default
    }

    const fullNode = { ...partialNode, modelName }
    return oldNode ? { ...oldNode, ...fullNode } : fullNode
  })

  return {
    ...newWorkflow,
    nodes: handledNodes, // overrides the spread-in value safely
  }
}
